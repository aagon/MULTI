#+TITLE : Prise de notes TP 4I106 MULTI
#+PROPERTY: header-args :mkdirp yes
#+STARTUP: inlineimages

Alain Greiner (alain.greiner@lip6.fr)

* TP 1 : 30/01/2020

Pour ce premier TP, on va d'intéresser au bus, qui est un bon exemple d'automate, et en particulier au Pi-bus, qui suit les règles suivantes :

Le pi-bus est un bus multimaître synchrone.

Deux types de composants matériels qui doivent communiquer entre eux :
- les maîtres sont par exemple les coeurs (et leurs caches privés)
- les cibles, comme la ram, la rom, le tty

La fonction du bus, c'est l'aiguillage et le routage.

On a avant toutes choses un bus de commandes, qui se décline en trois nappes de fils, ADDR (30 bits, puisqu'on ne ramène que des mots), OPC (4 bits), READ (1 bit).

Les seuls qui écrivent sur ce bus de commandes, ce sont les maîtres (et on peut d'ailleurs les définir comme ça).

On a un deuxième bus, le bus de réponses. Ce bus est unique, il s'appelle ACK (2 bits, car on a 3 réponses possibles READY, WAIT, ERROR) et seules les cibles peuvent écrire sur ce bus (on peut d'ailleurs les définir comme ça).

On a un bus de données qui est utilisé par les maîtres et les cibles (en effet, un maître veut pouvoir lire comme écrire).





On a un fil req et un fil gnt par maître qui arrive au BCU, bus control unit. (un des rarissimes automates non-Moore, donc Mealy général).

#+NAME: pibus
#+BEGIN_SRC dot

#+END_SRC


[dessin du pibus]


On peut spécifier un protocole du bus par son chronogramme :

Phase d'allocation : la demande du bus et la réponse doivent avoir lieu dans le même cycle d'horloge.

Phase d'adresse : les signaux Addr, lock, etc...

Phase de donnée : D et ACK 


L'allocation d'un nouveau maître peut se faire pendant le dernier (LOCK est à 0) cycle de la transaction n à condition que la valeur envoyée soit RDY ou ERROR.




** Question C1

*** Noeud IDLE

F : C(SEL)
A : C(READ).DELAY.SEL.ADR_OK
B : C(READ).C(DELAY).SEL.ADR_OK
C : READ.C(DELAY).SEL.ADR_OK
D : READ.DELAY.SEL.ADR_OK
E : C(ADR_OK).SEL

On a l'orthogonalité sur ce noeud :

F d'intersection nulle avec tous les autres (car SEL.C(SEL) = 0).
On se permet donc de l'éliminer.

E est d'intersection nulle avec tous les autres (car ADR_OK.C(ADR_OK) = 0)
On se permet donc de l'éliminer.

A est d'intersection nulle avec C et D (car READ.C(READ) = 0)
B est d'intersection nulle avec C et D (car READ.C(READ) = 0)

A est d'intersection nulle avec B (car DELAY.C(DELAY) = 0)

C est d'intersection nulle avec A et B (car READ.C(READ) = 0)
D est d'intersection nulle avec A et B (car READ.C(READ) = 0)
On a montré que A et B étaient d'intersection nulle avec tous les autres, et entre eux.
On peut donc éliminer A et B.

C est d'intersection nulle avec D (car DELAY.C(DELAY)).
On a montré que C et D étaient d'intersection nulle avec tous les autres, et entre eux.
On peut donc éliminer C et D.

On a bien l'orthogonalité pour IDLE.

La complétude :

A + B = C(READ).DELAY.SEL.ADR_OK + C(READ).C(DELAY).SEL.ADR_OK
A + B = C(READ).SEL.ADR_OK

C + D = READ.C(DELAY).SEL.ADR_OK + READ.DELAY.SEL.ADR_OK
C + D = READ.SEL.ADR_OK

Donc :

A + B + C + D = C(READ).SEL.ADR_OK + READ.SEL.ADR_OK
A + B + C + D = SEL.ADR_OK

Donc :

A + B + C + D + E = SEL.ADR_OK + SEL.C(ADR_OK)
A + B + C + D + E = SEL

Donc :

A + B + C + D + E + F = SEL + C(SEL) = 1

On a bien la somme de toutes les conditions de transition égale à 1.

*** Noeud R_WAIT

V : GO
V' : C(GO)

L'orthogonalité et la complétude sont triviale.

*** Noeud W_WAIT

U : GO
U' : C(GO)

L'orthogonalité et la complétude sont triviale.

*** Noeud R_OK

R : C(ADR_OK).SEL
S : ADR_OK.SEL
T : C(SEL)

L'orthogonalité est évidente :

T.R = 0
T.S = 0
R.S = 0

La complétude :

R + S = C(ADR_OK).SEL + ADR_OK.SEL
R + S = SEL

R + S + T = SEL + C(SEL) = 1

On a bien la complétude.

*** Noeud W_OK

X : ADR_OK.SEL
Y : C(ADR_OK).SEL
Z : C(SEL)

La démonstration de l'orthogonalité et de la complétude est symétrique à celle du noeud R_OK.

*** Noeud ERROR

On n'a pas de transition qui nous fait rester dans l'état ERROR.

On admet donc qu'on va dans l'état IDLE de manière inconditionnée.

G : 1

** Question C2

*** Noeud IDLE

Dans ces état, le matériel n'écrit pas sur le bus :

On a donc ACK_EN = 0
La valeur de ACK_VALUE n'a pas d'importance, on lui met NULL
On a DT_EN = 0 puisqu'on écrit pas sur le bus de données.
On n'écrit ni ne lit dans la mémoire, donc MEM_CMD est à NOP.

*** Noeud R_WAIT

Dans cet état, on écrit sur le bus ACK la valeur WAIT. On a donc besoin de mettre le signal ACK_VALUE à WAIT, et ACK_EN à 1.

On n'écrit pas sur le bus de données, puisque celles-ci ne sont pas encore prêtes (on envoie WAIT pour une raison). Donc DT_EN est à 0.

Le maître a demandé d'accéder à une zone de la mémoire en lecture, c'est donc la commande READ qu'on envoie vers la mémoire.

*** Noeud R_OK

Dans cet état, on écrit sur le bus ACK la valeur READY. On a donc besoin de mettre de signal ACK_VALUE à READY, et ACK_EN à 1.

On écrit sur le bus de données, puisque les données sont prêtes.

La commande à mettre dans MEM_CMD est ambigüe :
- Si on admet que la mémoire n'est pas capable d'obtenir une donnée dans le même cycle pendant lequel on lui a demandé, on n'aura jamais READ en sortie sur MEM_CMD pendant qu'on envoie la donnée sur le bus.
- Par contre, si on admet qu'elle en est capable, on a dans le même cycle READ sur MEM_CMD, puis dès la réception de la donnée (dans le même cycle donc) READY sur ACK_VALUE.

La valeur de ce fil en sortie dépend du paramètre L (NOP s'il est non nul, READ s'il est nul). (attention, on ne vient pas de transformer cette machine en machine de Mealy : L est un paramètre, choisi au démarrage de la machine, qui ne change plus ensuite.)

*** Noeud W_WAIT

Dans cet état, on écrit sur le bus ACK la valeur WAIT. On a donc besoin de mettre le signal ACK_VALUE à READY, et ACK_EN à 1.

On n'écrit pas sur le bus de données, on a reçu une instruction d'écriture, donc DT_EN est à 0.

Le maître a demandé d'accéder à une zone de la mémoire en écriture, c'est donc la commande WRITE qu'on envoie vers la mémoire.

*** Noeud W_OK

Dans cet état, on écrit sur le bus ACK la valeur READY. On a donc besoin de mettre de signal ACK_VALUE à READY, et ACK_EN à 1.

On n'écrit pas sur le bus de données, on a reçu une instruction d'écriture, donc DT_EN est à 0.

Pour la même raison que pour R_OK, la valeur de MEM_CMD dépendraa du paramètre L

*** Noeud ERROR

Dans cet état, on écrit sur le bus ACK pour signaler l'erreur.

On n'écrit pas sur le bus de données, on n'a rien à y écrire, ni aucune commande non plus à envoyer à la mémoire.

*** Résumé

|        | ACK_EN | ACK_VALUE | DT_EN | MEM_CMD                   |
|--------+--------+-----------+-------+---------------------------|
| IDLE   |      0 | NULL      |     0 | NOP                       |
| R_WAIT |      1 | WAIT      |     0 | READ                      |
| R_OK   |      1 | READY     |     1 | NOP (si !L), READ (si L)  |
| W_WAIT |      1 | WAIT      |     0 | WRITE                     |
| W_OK   |      1 | READY     |     0 | NOP (si !L), WRITE (si L) |
| ERROR  |      1 | ERROR     |     0 | NOP                       |


A priori, on n'a écrit sur les bus ACK comme DT qu'au moment où on avait le droit de le faire. En effet, si on se rappelle le chronogramme du PIBUS, les différents états : R_WAIT R_OK W_WAIT W_OK ERROR n'arrivent qu'après une demande du maître. On a donc le bus réservé pour la réponse (donc aucun problème pour le bus ACK), et éventuellement le bus DT réservé si on a une donnée à transmettre.

Donc notre fonction de génération ne créé pas de court-circuits.

** Question D1

*** Noeud INIT

On passe de INIT à RAM_REQ de manière inconditionnée.

Donc A = 1

*** Noeud RAM_REQ








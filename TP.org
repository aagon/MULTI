#+TITLE : Prise de notes TP 4I106 MULTI
#+PROPERTY: header-args :mkdirp yes
#+STARTUP: inlineimages

Alain Greiner (alain.greiner@lip6.fr)

* TP 1 : 30/01/2020

Pour ce premier TP, on va d'intéresser au bus, qui est un bon exemple d'automate, et en particulier au Pi-bus, qui suit les règles suivantes :

Le pi-bus est un bus multimaître synchrone.

Deux types de composants matériels qui doivent communiquer entre eux :
- les maîtres sont par exemple les coeurs (et leurs caches privés)
- les cibles, comme la ram, la rom, le tty

La fonction du bus, c'est l'aiguillage et le routage.

On a avant toutes choses un bus de commandes, qui se décline en trois nappes de fils, ADDR (30 bits, puisqu'on ne ramène que des mots), OPC (4 bits), READ (1 bit).

Les seuls qui écrivent sur ce bus de commandes, ce sont les maîtres (et on peut d'ailleurs les définir comme ça).

On a un deuxième bus, le bus de réponses. Ce bus est unique, il s'appelle ACK (2 bits, car on a 3 réponses possibles READY, WAIT, ERROR) et seules les cibles peuvent écrire sur ce bus (on peut d'ailleurs les définir comme ça).

On a un bus de données qui est utilisé par les maîtres et les cibles (en effet, un maître veut pouvoir lire comme écrire).





On a un fil req et un fil gnt par maître qui arrive au BCU, bus control unit. (un des rarissimes automates non-Moore, donc Mealy général).

#+NAME: pibus
#+BEGIN_SRC dot

#+END_SRC


[dessin du pibus]


On peut spécifier un protocole du bus par son chronogramme :

- Phase d'allocation : la demande du bus et la réponse doivent avoir lieu dans le même cycle d'horloge.

- Phase d'adresse : les signaux Addr, lock, etc...

- Phase de donnée : D et ACK 

L'allocation d'un nouveau maître peut se faire pendant le dernier (LOCK est à 0) cycle de la transaction n à condition que la valeur envoyée soit RDY ou ERROR.

** Question C1

*** Noeud IDLE

F : C(SEL)
A : C(READ).DELAY.SEL.ADR_OK
B : C(READ).C(DELAY).SEL.ADR_OK
C : READ.C(DELAY).SEL.ADR_OK
D : READ.DELAY.SEL.ADR_OK
E : C(ADR_OK).SEL

On a l'orthogonalité sur ce noeud :

F d'intersection nulle avec tous les autres (car SEL.C(SEL) = 0).
On se permet donc de l'éliminer.

E est d'intersection nulle avec tous les autres (car ADR_OK.C(ADR_OK) = 0)
On se permet donc de l'éliminer.

A est d'intersection nulle avec C et D (car READ.C(READ) = 0)
B est d'intersection nulle avec C et D (car READ.C(READ) = 0)

A est d'intersection nulle avec B (car DELAY.C(DELAY) = 0)

C est d'intersection nulle avec A et B (car READ.C(READ) = 0)
D est d'intersection nulle avec A et B (car READ.C(READ) = 0)
On a montré que A et B étaient d'intersection nulle avec tous les autres, et entre eux.
On peut donc éliminer A et B.

C est d'intersection nulle avec D (car DELAY.C(DELAY)).
On a montré que C et D étaient d'intersection nulle avec tous les autres, et entre eux.
On peut donc éliminer C et D.

On a bien l'orthogonalité pour IDLE.

La complétude :

A + B = C(READ).DELAY.SEL.ADR_OK + C(READ).C(DELAY).SEL.ADR_OK
A + B = C(READ).SEL.ADR_OK

C + D = READ.C(DELAY).SEL.ADR_OK + READ.DELAY.SEL.ADR_OK
C + D = READ.SEL.ADR_OK

Donc :

A + B + C + D = C(READ).SEL.ADR_OK + READ.SEL.ADR_OK
A + B + C + D = SEL.ADR_OK

Donc :

A + B + C + D + E = SEL.ADR_OK + SEL.C(ADR_OK)
A + B + C + D + E = SEL

Donc :

A + B + C + D + E + F = SEL + C(SEL) = 1

On a bien la somme de toutes les conditions de transition égale à 1.

*** Noeud R_WAIT

V : GO
V' : C(GO)

L'orthogonalité et la complétude sont triviale.

*** Noeud W_WAIT

U : GO
U' : C(GO)

L'orthogonalité et la complétude sont triviale.

*** Noeud R_OK

R : C(ADR_OK).SEL
S : ADR_OK.SEL
T : C(SEL)

L'orthogonalité est évidente :

T.R = 0
T.S = 0
R.S = 0

La complétude :

R + S = C(ADR_OK).SEL + ADR_OK.SEL
R + S = SEL

R + S + T = SEL + C(SEL) = 1

On a bien la complétude.

*** Noeud W_OK

X : ADR_OK.SEL
Y : C(ADR_OK).SEL
Z : C(SEL)

La démonstration de l'orthogonalité et de la complétude est symétrique à celle du noeud R_OK.

*** Noeud ERROR

On n'a pas de transition qui nous fait rester dans l'état ERROR.

On admet donc qu'on va dans l'état IDLE de manière inconditionnée.

G : 1

** Question C2

*** Noeud IDLE

Dans ces état, le matériel n'écrit pas sur le bus :

On a donc ACK_EN = 0
La valeur de ACK_VALUE n'a pas d'importance, on lui met NULL
On a DT_EN = 0 puisqu'on écrit pas sur le bus de données.
On n'écrit ni ne lit dans la mémoire, donc MEM_CMD est à NOP.

*** Noeud R_WAIT

Dans cet état, on écrit sur le bus ACK la valeur WAIT. On a donc besoin de mettre le signal ACK_VALUE à WAIT, et ACK_EN à 1.

On n'écrit pas sur le bus de données, puisque celles-ci ne sont pas encore prêtes (on envoie WAIT pour une raison). Donc DT_EN est à 0.

Le maître a demandé d'accéder à une zone de la mémoire en lecture, c'est donc la commande READ qu'on envoie vers la mémoire.

*** Noeud R_OK

Dans cet état, on écrit sur le bus ACK la valeur READY. On a donc besoin de mettre de signal ACK_VALUE à READY, et ACK_EN à 1.

On écrit sur le bus de données, puisque les données sont prêtes.

La commande à mettre dans MEM_CMD est ambigüe :
- Si on admet que la mémoire n'est pas capable d'obtenir une donnée dans le même cycle pendant lequel on lui a demandé, on n'aura jamais READ en sortie sur MEM_CMD pendant qu'on envoie la donnée sur le bus.
- Par contre, si on admet qu'elle en est capable, on a dans le même cycle READ sur MEM_CMD, puis dès la réception de la donnée (dans le même cycle donc) READY sur ACK_VALUE.

La valeur de ce fil en sortie dépend du paramètre L (NOP s'il est non nul, READ s'il est nul). (attention, on ne vient pas de transformer cette machine en machine de Mealy : L est un paramètre, choisi au démarrage de la machine, qui ne change plus ensuite.)

*** Noeud W_WAIT

Dans cet état, on écrit sur le bus ACK la valeur WAIT. On a donc besoin de mettre le signal ACK_VALUE à READY, et ACK_EN à 1.

On n'écrit pas sur le bus de données, on a reçu une instruction d'écriture, donc DT_EN est à 0.

Le maître a demandé d'accéder à une zone de la mémoire en écriture, c'est donc la commande WRITE qu'on envoie vers la mémoire.

*** Noeud W_OK

Dans cet état, on écrit sur le bus ACK la valeur READY. On a donc besoin de mettre de signal ACK_VALUE à READY, et ACK_EN à 1.

On n'écrit pas sur le bus de données, on a reçu une instruction d'écriture, donc DT_EN est à 0.

Pour la même raison que pour R_OK, la valeur de MEM_CMD dépendraa du paramètre L

*** Noeud ERROR

Dans cet état, on écrit sur le bus ACK pour signaler l'erreur.

On n'écrit pas sur le bus de données, on n'a rien à y écrire, ni aucune commande non plus à envoyer à la mémoire.

*** Résumé

|        | ACK_EN | ACK_VALUE | DT_EN | MEM_CMD                   |
|--------+--------+-----------+-------+---------------------------|
| IDLE   |      0 | NULL      |     0 | NOP                       |
| R_WAIT |      1 | WAIT      |     0 | READ                      |
| R_OK   |      1 | READY     |     1 | NOP (si !L), READ (si L)  |
| W_WAIT |      1 | WAIT      |     0 | WRITE                     |
| W_OK   |      1 | READY     |     0 | NOP (si !L), WRITE (si L) |
| ERROR  |      1 | ERROR     |     0 | NOP                       |


A priori, on n'a écrit sur les bus ACK comme DT qu'au moment où on avait le droit de le faire. En effet, si on se rappelle le chronogramme du PIBUS, les différents états : R_WAIT R_OK W_WAIT W_OK ERROR n'arrivent qu'après une demande du maître. On a donc le bus réservé pour la réponse (donc aucun problème pour le bus ACK), et éventuellement le bus DT réservé si on a une donnée à transmettre.

Donc notre fonction de génération ne créé pas de court-circuits.

** Question D1

*** Noeud INIT

On passe de INIT à RAM_REQ de manière inconditionnée.

Donc A = 1

*** Noeud RAM_REQ

On passe de RAM_REQ à RAM_A0 (demande de la première adresse) seulement si le bus est alloué. On a donc

B = GNT, et donc B' = C(GNT)

*** Noeud RAM_A0

On passe de RAM_A0 à RAM_A1_D0 (attente de la première donnée et demande de la deuxième adresse) de manière inconditionnée.

Même si la mémoire fait attendre le maître, on demande quand même la prochaine adresse.

Donc C = 1

*** Noeud RAM_A1_D0

Cet état signifie très exactement : *attente* de la première donnée et demande de la deuxième adresse.

La consigne précise :

#+BEGIN_QUOTE
Dans le cas des transactions de type rafale, on utilise une technique de pipe-line, pour effectuer, dans le même cycle et sur deux nappes de fils séparées, le transfert de l'adresse (i+1), en même temps que le transfert de la donnée (i).
#+END_QUOTE

Moi, le maître, je n'ai le droit de demander l'adresse i+1 que si je reçois READY sur le bus ACK pour ma demande de l'adresse i.

Donc

D = RDY et D' = C(RDY)

*** Noeud RAM_A2_D1

De même :

E = RDY et E' = C(RDY)

*** Noeud RAM_A3_D2

De même :

F = RDY et F' = C(RDY)

*** Noeud RAM_D3

De même :

G = RDY et G' = C(RDY)

*** Noeud W_REQ

Dans cet état, on demande l'accès au bus pour écrire dans le tty.

On ne passe dans l'état W_AD que si le bus nous a été donné, donc :

H = GNT et H' = C(GNT)

*** Noeud W_AD

Dans cet état, on envoie une instruction d'écriture sur le bus, à destination du tty.

On ne demande rien dans cet état, on en sort de manière inconditionnée.

Donc I = 1

*** Noeud W_DT

Dans cet état, le maître envoie le caractère et doit vérifier :
- Que le caractère qu'il a transmis est bien arrivé et a bien été traité.
- Qu'il a bien envoyé tous les caractères.

S'il a envoyé tous les caractères, il doit passer dans sa boucle d'attente de saisie du clavier.

Sinon, il doit envoyer le caractère suivant. Et pour cela, il doit demander le bus.

Donc K = RDY.LAST et L = RDY.C(LAST) et J = C(RDY)

On a bien la complétude et l'orthogonalité.

*** Noeud STS_REQ

Dans cet état, le maître veut vérifier la valeur du registre status du tty pour savoir si quelqu'un a écrit dans le terminal.

Pour lire cette valeur, il doit obtenir le bus.

Donc M = GNT et M' = C(GNT)

*** Noeud STS_AD

Dans cet état, le maître envoie l'adresse du registre status du tty, il ne demande rien, il sort de cet état de manière inconditionnée.

Donc N = 1

*** Noeud STS_DT

Dans cet état, le maître doit vérifier :
- Qu'il a bien reçu le contenu du registre status du tty.
- Que la valeur de ce registre est bien non nulle, auquel cas il va demander de lire le registre keybuf du terminal.

Donc O = C(RDY) et P = RDY.C(NUL) et Q = RDY.NUL

On a bien la complétude et l'orthogonalité.

*** Noeud BUF_REQ

Dans cet état, le maître veut lire la valeur du registre keybuf du terminal.

Pour ça, il doit obtenir le bus.

Donc R = GNT et R' = C(GNT)

*** Noeud BUF_AD

Dans cet état, le maître envoie une demande en lecture vers le terminal, il n'attend rien.

On sort de cet état de manière inconditionnée.

Donc S = 1

*** Noeud BUF_DT

Dans cet état, le maître doit simplement attendre la donnée du registre keybuf du terminal.

Donc T = RDY et T' = C(RDY)

** Question D2

*** Noeud INIT

Dans cet état, le maître ne demande rien, n'a pas le bus de commandes ni le bus de données.

On a donc C(REQ), C(CMD_EN), C(DT_EN).

Les signaux ADR_VALUE, READ_VALUE, et LOCK_VALUE ne sont pas applicables, ils ne sont pas envoyés.

*** Noeud RAM_REQ

Dans cet état, le maître demande le bus, mais il ne l'a pas encore. Il n'a pas le droit d'écrire, ni sur le bus de données, ni sur le bus de commandes.

On a donc REQ, C(CMD_EN), C(DT_EN).

Les signaux ADR_VALUE, READ_VALUE, et LOCK_VALUE ne sont toujours pas applicables, ils ne sont pas envoyés.

*** Noeud RAM_A0

Dans cet état, le maître a le bus, il demande l'adresse RAM_BASE.

Le signal REQ passe à 0, parce que la consigne spécifie que celui-ci est utilisé seulement pour demander le bus, pas pour le garder (c'est le signal LOCK_VALUE qui remplit ce rôle).

On envoie une demande, il faut donc autoriser l'émission sur le bus de commandes, donc le signal CMD_EN est activé.

Il s'agit d'une requête en lecture, donc READ_VALUE est à 1.

Il s'agit d'une demande rafale, et cette demande n'est pas la dernière de la rafale. On mettra donc le signal LOCK_VALUE.

On n'écrit pas sur le bus de données, donc DT_EN est à 0.

*** Noeud RAM_A1_D0

Dans cet état, le maître a le bus, il demande l'adresse RAM_BASE+4.

Le signal REQ passe à 0, parce que la consigne spécifie que celui-ci est utilisé seulement pour demander le bus, pas pour le garder (c'est le signal LOCK_VALUE qui remplit ce rôle).

On envoie une demande, il faut donc autoriser l'émission sur le bus de commandes, donc le signal CMD_EN est activé.

Il s'agit d'une requête en lecture, donc READ_VALUE est à 1.

Il s'agit d'une demande rafale, et cette demande n'est pas la dernière de la rafale. On mettra donc le signal LOCK_VALUE.

On n'écrit pas sur le bus de données, donc DT_EN est à 0.

*** Noeud RAM_A2_D1

Pareil que l'état précédent, on prendra bien garde à changer la valeur de la variable ADR_VALUE.

*** Noeud RAM_A3_D2

Pareil que l'état précédent, on prendra bien garde à changer la valeur de la variable ADR_VALUE.

On signalera aussi que la commande est la dernière de la rafale en mettant le signal LOCK_VALUE à 0.

*** Noeud RAM_D3

Dans cet état, le maître n'envoie plus de commandes, donc ADR_VALUE et READ_VALUE et LOCK_VALUE ne sont plus applicables, et CMD_EN est à 0.

On ne demande pas le bus, donc REQ est à 0.

On n'écrit pas sur le bus de données, donc DT_EN est à 0.

*** Noeud W_REQ

Dans cet état, le maître demande le bus, on met donc REQ à 1.

Il ne l'a pas reçu, donc il n'a pas le droit d'écrire sur le bus de commandes. Donc CMD_EN est à 0, et ADR_VALUE, READ_VALUE et LOCK_VALUE ne sont pas applicables.

On n'écrit pas sur le bus de données non plus, donc DT_EN est à 0.

*** Noeud W_AD

Dans cet état, le maître a obtenu le bus, il lance une requête d'écriture simple sur le bus à destination de l'adresse TTY_BASE.

On a donc REQ à 0, CMD_EN à 1, ADR_VALUE à TTY_BASE, READ_VALUE à 0, LOCK_VALUE à 0.

Ici, on a une ambigüité : le maître envoie-t-il les données dans cet état, ou dans l'état suivant ? Le modèle fourni par soclib semble pencher pour la deuxième option, même s'il n'est nulle part question de cycle de décalage entre la requête d'écriture et l'envoi effectif des données.

Le chronogramme (tp1_chronogramme.png) semble aussi pencher pour la deuxième option.

On met donc DT_EN à 0

*** Noeud W_DT

Dans cet état, le maître envoie les données du caractère sur le bus de données, on met donc DT_EN à 1.

Sinon, il n'envoie pas de commandes, ni ne demande le bus.

*** Noeud STS_REQ

Dans cet état, le maître veut obtenir le bus. On a donc REQ à 1.

Puisqu'il ne l'a pas, il n'écrit ni sur le bus de commandes, ni sur le bus de données.

*** Noeud STS_AD

Dans cet état, le maître envoie une requête en lecture simple vers l'adresse TTY_BASE+4. Il n'utilise pas le bus de données.

*** Noeud STS_DT

Dans cet état, le maître reçoit la réponse du terminal. Il ne demande pas le bus, il n'envoie pas de commandes, ni de données.

*** Noeud BUF_REQ

Dans cet état, le maître veut obtenir le bus. On donc REQ à 1.

Puisqu'il ne l'a pas, il n'écrit ni sur le bus de commandes, ni sur le bus de données.

*** Noeud BUF_AD

Dans cet état, le maître a obtenu le bus, il lance une requête simple en lecture vers l'adresse TTY_BASE+8. Il n'utilise pas le bus de données.

*** Noeud BUF_DT

Dans cet état, le maître attend la réponse du terminal. Il n'utilise aucun bus.

*** Résumé

|           | REQ | CMD_EN | ADR_VALUE   | READ_VALUE | LOCK_VALUE | DT_EN |
|-----------+-----+--------+-------------+------------+------------+-------|
| INIT      |   0 |      0 | NULL        | NULL       | NULL       |     0 |
| RAM_REQ   |   1 |      0 | NULL        | NULL       | NULL       |     0 |
| RAM_A0    |   0 |      1 | RAM_BASE    | 1          | 1          |     0 |
| RAM_A1_D0 |   0 |      1 | RAM_BASE+4  | 1          | 1          |     0 |
| RAM_A2_D1 |   0 |      1 | RAM_BASE+8  | 1          | 1          |     0 |
| RAM_A3_D2 |   0 |      1 | RAM_BASE+12 | 1          | 0          |     0 |
| RAM_D3    |   0 |      0 | NULL        | NULL       | NULL       |     0 |
| W_REQ     |   1 |      0 | NULL        | NULL       | NULL       |     0 |
| W_AD      |   0 |      1 | TTY_BASE    | 0          | 0          |     0 |
| W_DT      |   0 |      0 | NULL        | NULL       | NULL       |     1 |
| STS_REQ   |   1 |      0 | NULL        | NULL       | NULL       |     0 |
| STS_AD    |   0 |      1 | TTY_BASE+4  | 1          | 0          |     0 |
| STS_DT    |   0 |      0 | NULL        | NULL       | NULL       |     0 |
| BUF_REQ   |   1 |      0 | NULL        | NULL       | NULL       |     0 |
| BUF_AD    |   0 |      1 | TTY_BASE+8  | 1          | 0          |     0 |
| BUF_DT    |   0 |      0 | NULL        | NULL       | NULL       |     0 |

On a tenu à distinguer NULL et 0 pour distinguer les cas où le signal était effectivement signifiant. Dans les fait, NULL peut prendre n'importe quelle valeur, le signal n'est pas transmis. On imagine qu'il prend la valeur 0.

** Question E1

*** Noeud IDLE

On reste dans l'état IDLE seulement si personne ne demande le bus.

Donc X' = C(REQ) et X = REQ

On a de manière évidente l'orthogonalité et la complétude.

*** Noeud AD

Dans cet état, le bus a été alloué à un maître, et c'est la première commande.

La première commande est en même temps la dernière commande si, et seulement si, LOCK est à 0. Sinon, on est la première commande d'une rafale, et donc on va dans l'état DTAD.

Donc Y = LOCK et Y' = C(LOCK)

On a de manière évidente l'orthogonalité et la complétude.

*** Noeud DTAD

Dans cet état, le bus a été alloué à un maitre, et on est au milieu d'un transaction rafale : CMD(i) / RSP(i-1).

On ne sort de cet état que si :
- la commande envoyée est bien la dernière
- On a bien reçu soit READY, soit ERROR de la cible.

Donc Z = C(WAIT).C(LOCK) et Z' = WAIT + LOCK

On a de manière évidente l'orthogonalité et la complétude.

*** Noeud DT

On ne sort de cet état que si la réponse de la cible est READY ou ERROR.

Donc J = WAIT

On ne retourne dans l'état IDLE que si personne n'a demandé le bus.

Donc K = C(WAIT).C(REQ)

On ne retourne dans l'état AD que si quelqu'un a demandé le bus.

Donc L = C(WAIT).REQ

On a l'orthogonalité et la complétude par construction.

** Question E2

*** Noeud IDLE

On se rappelle ici le fait que cet automate est un automate de Mealy. Le BCU est censé répondre à la requête du maître dans le même cycle.

Le signal GNT est donc activé à la suite de la réception du signal REQ.

Le maître n'a encore sélectionné personne, les signaux de sélection sont à 0.

*** Noeud AD

Dans cet état, le maître a sélectionné un maître et une cible. Dans ce PIBUS simplifié, on a seulement deux cibles possibles, la RAM et le tty.

On active bien entendu qu'un seul des deux signaux SEL0 et SEL1, sous peine de court-circuit.

On active SEL0 si les bits de poids fort correspondent à une adresse de la RAM, SEL1 sinon.

On n'a pas besoin d'activer le signal GNT, le bus a déjà été attribué.

*** Noeud AD/DT

Pareil qu'au noeud précédent.

*** Noeud DT

Dans ce noeud, le bus a été alloué à un maître, et c'est la réponse à la dernière commande.

On n'a pas de commande, donc SEL0 et SEL1 sont à 0.

Si la réponse de la cible est WAIT, on reste dans cet état, on continue à attendre.

Si la réponse de la cible n'est pas WAIT, c'est que le maître courant a fini sa demande (qu'elle soit valable ou non). On peut donc déjà attribuer le bus à un autre maître (ou au même), pour qu'il puisse faire sa commande au prochain cycle. Si le maître requiert le bus (signal REQ), on le lui donne (signal GNT).

*** Résumé

|       | GNT         | SEL0          | SEL1          |
|-------+-------------+---------------+---------------|
| IDLE  | REQ         | 0             | 0             |
| AD    | 0           | DEC(A) == RAM | DEC(A) != RAM |
| DT/AD | 0           | DEC(A) == RAM | DEC(A) != RAM |
| DT    | REQ.C(WAIT) | 0             | 0             |

** Question E3

Comme on l'a déjà expliqué, les contraintes se limitent strictement à :
- on doit laisser un cycle entre la commande d'un maître et la commande d'un autre maître
- le bcu doit répondre au maître dans le même cycle que la demande

Donc, lors de la réponse à la dernière commande d'un maître, la dernière fois que le maître en question a parlé, c'était au cycle précédent. On peut donc se permettre de faire parler un autre maître au cycle suivant. Pour pouvoir faire parler un maître au cycle suivant, il faut lui accorder le bus là maintenant.

Donc, on alloue le maître non seulement dans l'état IDLE, mais aussi dans l'état DT, pour gagner un cycle. 

** Question F1

Instanciation des deux matériels manquants :

#+BEGIN_SRC c++
  PibusSimpleMaster		master	("master", SEG_RAM_BASE, SEG_TTY_BASE);
  PibusSimpleRam		ram	("ram"  , 0, segtable, ram_latency, loader);
#+END_SRC

Connexion des deux matériels manquants :

Commençons par la ram :
- on connecte le signal d'horloge, le signal de reset, et le signal de "tout" (on ne sait pas ce qu'il fait)

#+BEGIN_SRC c++
  ram.p_ck(signal_ck);
  ram.p_resetn(signal_resetn);
  ram.p_tout(signal_pi_tout);
#+END_SRC

- on connecte le signal de sélection (SEL0) :

#+BEGIN_SRC c++
  ram.p_sel(signal_sel_ram);
#+END_SRC

- On connecte le signal d'adresse, d'opcode, de read, de data, de ack :

#+BEGIN_SRC c++
  ram.p_a(signal_pi_a);
  ram.p_read(signal_pi_read);
  ram.p_opc(signal_pi_opc);
  ram.p_ack(signal_pi_ack);
  ram.p_d(signal_pi_d);
#+END_SRC

Ensuite, le maître :
- On commence toujours par le signal d'horloge, de reset, et de tout :

#+BEGIN_SRC c++
  master.p_ck(signal_ck);
  master.p_resetn(signal_resetn);
  master.p_tout(signal_pi_tout);
#+END_SRC

- On connecte le signal de req, de gnt, de lock :

#+BEGIN_SRC c++
  master.p_req(signal_req_master);
  master.p_gnt(signal_gnt_master);
  master.p_lock(signal_pi_lock);
#+END_SRC

- On connecte le signal de addr, opc, read, data, et ack :

#+BEGIN_SRC c++
  master.p_a(signal_pi_a);
  master.p_opc(signal_pi_opc);
  master.p_read(signal_pi_read);
  master.p_d(signal_pi_d);
  master.p_ack(signal_pi_ack);
#+END_SRC

** Question F2

Ajout du segment du tty :

#+BEGIN_SRC c++
  segtable.addSegment("seg_tty", SEG_TTY_BASE, 0x00000010, 1, false);
#+END_SRC

On lui donne le nom "seg_tty", on le fait commencer à SEG_TTY_BASE, on sait par la consigne qu'il occupe 16 octets (4 registres d'un mot chacun), l'identifiant de la cible tty est 1, et on désactive le cache.

** Question F3

Comment est initialisée la chaîne de caractères "Hello World!" dans la mémoire ?

Le constructeur de l'objet PibusSimpleRam prend en dernier argument une référence vers un objet Loader.

L'objet Loader qu'on lui a passé en paramètre est loader, qu'on a instancié trois lignes plus haut :

Le constructeur de cet objet loader prend en paramètre une chaîne de caractères, probablement parsée :
- string_file : un cheminom de fichier qui contient les données à charger
- 0x10000000 : l'adresse à laquelle charger ces données
- D : un flag, apparemment

** Question G1

En exécutant la commande :

#+BEGIN_SRC shell
  time ./simul.x -NCYCLES 1000000
#+END_SRC

On obtient :

real    0m3.993s
user    0m1.578s
sys     0m1.146s

Donc 1000000 de cycles simulés en 4 secondes, soient 250000 cycles par secondes, soit 250 kHz.

La condition selon laquelle SystemC ne doit pas être pire que 1000 fois moins rapide que le matériel est à peu près tenue, si on suppose un matériel simulé à 250 MHz.

** Question G2

Combien y-a-t-il de cycles d'attente dans les états de l'automate du composant maître où celui-ci demande au BCU l'allocation du bus ? Expliquez ce comportement.

On admet que la question signifie : combien y a-t-il de cycles d'attente entre la demande du bus par le maître et son allocation ?

Il n'y a aucun cycle d'attente entre la demande du bus et son allocation : on a l'activation du signal REQ, qui demande le bus, et du signal GNT, qui l'accorde, dans les mêmes cycles.

Ce comportement est voulu. On veut pouvoir répondre au maître tout de suite. Cette chose est rendus possible par le fait que le BCU est un automate de Mealy : son signal GNT peut être activé de manière asynchrone aux fronts d'horloge.

** Question G3

Combien y-a-t-il de cycles d'attente dans les états de l'automate du composant maître ou celui-ci attend la réponse de la RAM ? Expliquez ce comportement.

On admet que la question signifie :

Combien faut-il de cycles entre l'arrivée de la demande du maître à la RAM et le passage de la RAM dans l'état READ_OK (qui signifie que la RAM envoie les données demandées sur le bus) ?

Avec les paramètres qu'on a choisi, on a deux cycles d'attente.

Regardons pour cela les cycles 1, 2, 3 et 4.

(Pour une raison inexpliquée, le maître ne commence pas dans l'état INIT, mais directement dans l'état RAM_A0.)

#+BEGIN_QUOTE
,*******  cycle = 1 *******
bcu : fsm = AD | selected target = 0
master : state = RAM_A0
ram : IDLE
tty : IDLE   keyboard status[0] = 0   display status[0] = 0
req     = 0
gnt     = 0
sel_ram = 1
sel_tty = 0
avalid  = 1
read    = 1
lock    = 1
address = 0x10000000
ack     = 0
data    = 0
,*******  cycle = 2 *******
bcu : fsm = DTAD | selected target = 0
master : state = RAM_A1_D0
ram : READ_WAIT
tty : IDLE   keyboard status[0] = 0   display status[0] = 0
req     = 0
gnt     = 0
sel_ram = 1
sel_tty = 0
avalid  = 1
read    = 1
lock    = 1
address = 0x10000004
ack     = 0
data    = 0
,*******  cycle = 3 *******
bcu : fsm = DTAD | selected target = 0
master : state = RAM_A1_D0
ram : READ_WAIT
tty : IDLE   keyboard status[0] = 0   display status[0] = 0
req     = 0
gnt     = 0
sel_ram = 1
sel_tty = 0
avalid  = 1
read    = 1
lock    = 1
address = 0x10000004
ack     = 0
data    = 0
,*******  cycle = 4 *******
bcu : fsm = DTAD | selected target = 0
master : state = RAM_A1_D0
ram : READ_OK
tty : IDLE   keyboard status[0] = 0   display status[0] = 0
req     = 0
gnt     = 0
sel_ram = 1
sel_tty = 0
avalid  = 1
read    = 1
lock    = 1
address = 0x10000004
ack     = 0x2
data    = 0x6c6c6548
#+END_QUOTE

Le cycle 1 est la demande du maître. Celle-ci arrive à la fin du cycle 1, la RAM sort de l'état IDLE avec le front montant du cycle 2.

La RAM reste dans l'état READ_WAIT jusqu'à la fin du cycle 3, soient deux cycles entiers.

On a donc deux cycles d'attente pour la première demande, ce qui correspond bien au paramètre ram_latency qu'on a choisi. (pas d'attente en revanche pour les demandes suivantes de la rafale, ce qui correspond à notre modélisation de la RAM)

** Question G4

On admet que la question signifie :

Combien faut-il de cycles, *depuis un état initial INIT du maître*, pour afficher un caractère sur le composant PIBUS_MULTI_TTY ?

On commence donc par se placer dans le premier état INIT du maître (dont l'index du cycle n'est pas déterministe, il dépend en fait du temps qu'on a fait tourner le maître à attendre notre input au clavier).

Il se trouve que dans ma trace, ce premier état initial INIT est au cycle 9389. On recherche donc à partir de ce cycle-là le premier état DISPLAY du TTY, avec 0x48 ('H') en data.

C'est le cycle 9400.

Il faut donc 9400 - 9389 = 11 cycles pour afficher un caractère dans le composant PIBUS_MULTI_TTY depuis l'état inital INIT du maître, étant donné les valeurs de latence de la RAM données en paramètres (soit 2 dans notre cas, variable ram_latency que nous n'avons pas modifié).

** Question G5

Comme on l'a déjà dit, le maître commence directement dans l'état RAM_A0 pour une raison inexpliquée.

Le chronogramme tiendra compte de cet état de choses, et commencera aussi dans cet état-là.

Ci-joint donc un chronogramme des cycles 1 à 20 compris :

[[./TP1/chronogramme.png][Chronogramme]]


On s'est permis de spécifier à certains endroits un signal XXX pour "don't care". On voulait en fait faire remarquer que personne n'écrivait à ce moment-là. Laisser la valeur résiduelle des cycles précédents aurait fonctionné aussi, mais on aurait eu plus de mal à faire la différence entre un signal effectivement envoyé et un signal résiduel dont il ne faut pas tenir compte.


* TP 2 : 07/02/2020

** Question C1

On a direct mapping, soit icache_ways = 1

On a 16 octets par ligne de cache, soit 4 mots, donc icache_words = 4

1024 / 16, soient 64 lignes, donc icache_sets = 64

De même pour les caches de données.

** Question C2

Il faut pouvoir garantir que la machine rebootera après un arrêt intempestif.

Pour que notre automate soit déterministe, il faut qu'il ait un unique état initial connu et constant.

Cet état initial est donné par le contenu du segment seg_reset.

Il faut absolument que ce segment mappe vers une zone de la mémoire en lecture seule.

** Question C3

Le segment seg_tty doit être non cachable, parce que les caractères affichés dans le terminal doivent toujours correspondre effectivement à ce que le processeur connaît.

Le cache permet que ces deux valeurs soient différentes, même transitoirement, et c'est inacceptable.

** Question C4

Les segments protégés sont :
- seg_reset
- seg_kcode
- seg_kdata
- seg_kdata
- seg_tty

On le repère à ce que ils font partie des adresses hautes (bit de poids fort à 1).

** Question D1

Le programme utilisateur doit donner au noyau :
- la référence de l'appel système qu'il appelle
- les paramètres

La première information est facile à transmettre :
Les noms et les comportements des appels systèmes sont réputés connus de l'utilisateur (ils sont documentés) : il suffit de passer un nom, et le noyau a une liste statique des appels systèmes. Il cherche dans sa liste et trouve (ou non, auquel cas il rend une erreur).

La deuxième information est un peu plus délicate à transmettre : le noyau et le userspace n'ont pas la même pile : le noyau, qui a tous les droits, peut aller chercher les arguments directement dans la pile utilisateur du processus qui a fait l'appel système (c'est ce que faisait unix v5).

Sinon, comme c'est le cas ici, on peut stocker les arguments dans des registres visibles du processeur. Cette technique suppose une quantité limitée d'arguments.

En général, c'est même une technique mixte qui est utilisée : les premiers arguments peuvent être mis dans des registres, et la suite peut-être mise ou bien dans la pile ou bien dans une zone précise de l'espace mémoire du processus appelant.

** Question D2

Le tableau _cause_vector contient les raisons d'entrée en mode noyau. Il est initialisé dans le fichier exc_handler.c.

Le tableau _syscall_vector contient les points d'entrée des handlers des appels systèmes. Il est initialisé dans le fichier sys_handler.c.

D'après le code assembleur de la fonction _sys_handler, les handlers des appels systèmes sont indexés par leurs 5 bits de poids faible (donc 32 handlers) :

#+BEGIN_SRC mips
	  andi        $26,$2,0x1F
#+END_SRC

** Question D3

Dans l'ordre :

L'utilisateur appelle la fonction utilisateur proctime().

La fonction proctime() appelle la fonction inlinée sys_call(), avec comme premier argument 0x01, soit l'index de la fonction *noyau* _proctime() dans le tableau _syscall_vector.

La fonction syscall() enregistre dans des registres du processeur les arguments de la fonction, et il appelle l'instruction MIPS "syscall".

On fait l'hypothèse que cette instruction permet de passer en mode noyau (donc de rendre accessible des instructions processeur et des adresses), et de jump à une adresse bien précise. Ce passage en mode noyau se fait au moyen d'une trappe, soit une interruption matérielle.

On fait l'hypothèse, appuyée sur le code, qu'on saute à l'adresse 0x80000000 (en fait 0x80000000 + 0x180), soit l'adresse de la fonction assembleur _giet. Cette fonction assembleur du noyau a pour but de regarder quelle est la cause de l'interruption matérielle. Il se trouve que la cause de l'interruption matérielle courante suppose l'appel à la fonction assembleur _sys_handler.

On saute donc vers la fonction _sys_handler.

La fonction _sys_handler consulte le tableau _syscall_vector, et voit donc que le handler à appeler est la fonction _proctime.

_sys_handler saute donc vers la fonction _proctime (et il prend la peine de désactiver les interruptions : le noyau est *non-préemptif*) :

#+BEGIN_SRC mips
	  jalr        $3
	  mtc0        $0,$12                 
#+END_SRC

(on est en MIPS 32 bits, avec 5 étages de pipeline et un delayed slot : l'instruction mtc0 est exécutée malgré le jump)

La fonction _proctime consiste en une ligne d'assembleur, qui va lire le contenu du registre $9 du coprocesseur 0, censé apparemment contenir le nombre de cycles de processeurs écoulés depuis le démarrage de la machine (on ne sait pas trop comment, le code ne permet pas de le dire).

Cette valeur est copiée dans une variable de la pile, appelée ret. Cette variable est retournée par la fonction.

On se retrouve à la ligne suivante :

#+BEGIN_SRC mips
	  lw          $26,16($29)
	  mtc0        $26,$12
#+END_SRC

La fin de la fonction restaure les pointeurs de pile et d'instructions.

On se retrouve en mode utilisateur, à la fin de la fonction sys_call().

Qui retourne la valeur qui a été opportunément placée dans la pile au bon endroit (dans la variable reg_no_and_output).

On se trouve à la fin de la fonction proctime().

** Question D4

Cet appel système dont on vient de détailler le déroulement a le coût en *instructions* suivant, calculé sur la base des fichiers app.bin.txt et sys.bin.txt, qui sont les codes objets désassemblés :

Dans la fonction proctime :

400094:	27bdffe0 	addiu	sp,sp,-32
400098:	afbf001c 	sw	ra,28(sp)
40009c:	afbe0018 	sw	s8,24(sp)
4000a0:	03a0f025 	move	s8,sp
4000a4:	afa00010 	sw	zero,16(sp)
4000a8:	00003825 	move	a3,zero
4000ac:	00003025 	move	a2,zero
4000b0:	00002825 	move	a1,zero
4000b4:	24040001 	li	a0,1
4000b8:	0c100000 	jal	400000 <sys_call>
4000bc:	00000000 	nop

(soient 11 instructions)

Dans la fonction sys_call :

400000:	27bdfff8 	addiu	sp,sp,-8
400004:	afbf0004 	sw	ra,4(sp)
400008:	afbe0000 	sw	s8,0(sp)
40000c:	03a0f025 	move	s8,sp
400010:	afc40008 	sw	a0,8(s8)
400014:	afc5000c 	sw	a1,12(s8)
400018:	afc60010 	sw	a2,16(s8)
40001c:	afc70014 	sw	a3,20(s8)
400020:	8fc20008 	lw	v0,8(s8)
400024:	8fc4000c 	lw	a0,12(s8)
400028:	8fc50010 	lw	a1,16(s8)
40002c:	8fc60014 	lw	a2,20(s8)
400030:	8fc70018 	lw	a3,24(s8)
400034:	0000000c 	syscall

(soient 14 instructions)

Dans la fonction _giet :

80000180:	401b6800 	mfc0	k1,c0_cause
80000184:	3c1a8200 	lui	k0,0x8200
80000188:	275a00d0 	addiu	k0,k0,208
8000018c:	337b003c 	andi	k1,k1,0x3c
80000190:	035bd021 	addu	k0,k0,k1
80000194:	8f5a0000 	lw	k0,0(k0)
80000198:	03400008 	jr	k0
8000019c:	00000000 	nop

(soient 8 instructions)

Dans la fonction _sys_handler :

800001a0:	27bdffe8 	addiu	sp,sp,-24
800001a4:	401a6000 	mfc0	k0,c0_status
800001a8:	afba0010 	sw	k0,16(sp)
800001ac:	401b7000 	mfc0	k1,c0_epc
800001b0:	277b0004 	addiu	k1,k1,4
800001b4:	afbb0014 	sw	k1,20(sp)
800001b8:	305a001f 	andi	k0,v0,0x1f
800001bc:	001ad080 	sll	k0,k0,0x2
800001c0:	3c1b8200 	lui	k1,0x8200
800001c4:	277b031c 	addiu	k1,k1,796
800001c8:	037ad821 	addu	k1,k1,k0
800001cc:	8f630000 	lw	v1,0(k1)
800001d0:	241bffed 	li	k1,-19
800001d4:	401a6000 	mfc0	k0,c0_status
800001d8:	035bd024 	and	k0,k0,k1
800001dc:	0060f809 	jalr	v1
800001e0:	409a6000 	mtc0	k0,c0_status

(soient 17 instructions)

Dans la fonction _proctime :

80000520:	27bdfff0 	addiu	sp,sp,-16
80000524:	afbe000c 	sw	s8,12(sp)
80000528:	03a0f025 	move	s8,sp
8000052c:	40024800 	mfc0	v0,c0_count
80000530:	afc20000 	sw	v0,0(s8)
80000534:	8fc20000 	lw	v0,0(s8)
80000538:	03c0e825 	move	sp,s8
8000053c:	8fbe000c 	lw	s8,12(sp)
80000540:	27bd0010 	addiu	sp,sp,16
80000544:	03e00008 	jr	ra
80000548:	00000000 	nop

(soient 11 instructions)

De retour dans la fonction _sys_handler :

800001e4:	40806000 	mtc0	zero,c0_status
800001e8:	8fba0010 	lw	k0,16(sp)
800001ec:	409a6000 	mtc0	k0,c0_status
800001f0:	8fba0014 	lw	k0,20(sp)
800001f4:	409a7000 	mtc0	k0,c0_epc
800001f8:	27bd0018 	addiu	sp,sp,24
800001fc:	42000018 	eret

(soient 7 instructions)

De retour dans la fonction sys_call (on est donc sorti du mode noyau) :

400038:	03c0e825 	move	sp,s8
40003c:	8fbf0004 	lw	ra,4(sp)
400040:	8fbe0000 	lw	s8,0(sp)
400044:	27bd0008 	addiu	sp,sp,8
400048:	03e00008 	jr	ra
40004c:	00000000 	nop

(soient 6 instructions)

De retour dans la fonction proctime :

4000c0:	03c0e825 	move	sp,s8
4000c4:	8fbf001c 	lw	ra,28(sp)
4000c8:	8fbe0018 	lw	s8,24(sp)
4000cc:	27bd0020 	addiu	sp,sp,32
4000d0:	03e00008 	jr	ra
4000d4:	00000000 	nop

(soient 6 instructions)

Donc, depuis l'appel à la fonction proctime par le programme applicatif, à la sortie de cette même fonction, on a un coût en instructions :

*37 instructions* en mode utilisateur
*43 instructions* en mode système

Soient un grand total de *80 instructions*.

Si on suppose, en raison des delayed slots, cycles de gels, accès mémoire, etc..., un CPI de 2, on a donc *160 cycles* dépensés pour cet accès à proctime.

** Question E1

En général, le code de boot doit être exécuté en mode système parce que le boot consiste entre autres à charger le code du noyau en mémoire centrale, et en zone noyau de la mémoire centrale. Pour accéder en écriture à cette zone, on doit être en mode noyau.

Dans notre cas, quand bien même on suppose le code du noyau déjà chargé en mémoire au démarrage de la machine, on est quand même censé manipuler des registres, comme le registre SR, qui n'est accessible qu'en mode noyau.

** Question E2

L'adresse du point d'entrée du code applicatif doit se trouver au début du segment seg_data_base (soit exactement à l'adresse 0x01000000) :

#+BEGIN_SRC mips
	  la	         $26,seg_data_base
	  lw	         $26,0($26)          # get the user code entry point
	  mtc0	         $26,$14             # write it in EPC register
#+END_SRC

C'est bien cette adresse située à l'adresse 0x01000000 qui est chargée dans le compteur ordinal.

** Question E3

Si les adresses définies dans ces deux fichiers ne sont pas égales entre elles, le logiciel essaiera d'accéder à des adresses erronnées, puisque la base des segments pour le logiciel ne sera pas la même que la base des segments pour le matériel.

** Question E4

Le segment seg_reset contient seulement le code de la fonction assembleur reset.

Le segment seg_kcode contient le code de la fonction assembleur giet (le point d'entrée du noyau) et le code de toutes les fonctions du noyau définies dans les fichiers drivers.c, common.c, ctx_handler.c, irq_handler.c, sys_handler.c et exc_handler.c. Lors de la compilation, le code objet est préfixé d'une espèce de tag, .text, qui fait que l'éditeur de liens sait quelles fonctions mettre dans quel segment.

** Question E5

D'après le fichier sys.bin.txt, le segment seg_reset va des adresses [0xbfc00000 ; 0xbfc00023], soit 36 octets.

D'après le fichier sys.bin.txt, le segment seg_kcode effectivement occupé va des adresses [0x80000180 ; 0x8000227c] compris (on ne compte pas la section .MIPS.abiflags), soit :

8448 octets

** Question E6

#+BEGIN_SRC c
  #include "stdio.h"

  __attribute__((constructor)) void main()
  {
	  char c;
	  char s[] = "\n Hello World! \n";

	  while (1) {
		  tty_puts(s);
		  tty_getc(&c);
	  }
  }
#+END_SRC

** Question E7

Bien évidemment que la boucle non-déterministe (dans le sens où on ne saura pas quand on en sortira) est dans la fonction utilisateur tty_getc et non pas dans la fonction noyau _tty_read ! Aucun programmeur système sain d'esprit n'implémenterait une boucle non-déterministe dans du code noyau, surtout si le noyau est non-préemptif, multi-processus, en temps partagé (ce qui est le cas du GIET).

Les raisons pour ne pas faire ça sont légion, mais la plus évidente est la suivante : on a vu que les interruptions matérielles étaient masquées pendant l'exécution des fonctions noyau. Autrement dit, si la boucle avait été mise dans la fonction noyau, le processeur reste dans cette fonction noyau, oublieux de toutes les interruptions matérielles, même des interruptions horloge, *et rien ne peut plus l'en faire sortir* (sinon bien entendu le fait que l'utilisateur décide d'appuyer sur une touche de son clavier, ce qui peut très bien ne jamais arrivé). Ce processus qui exécute la fonction ne peut pas être tué, ne peut pas recevoir quelque signal que ce soit, et *ne peut pas être commuté*. Si il se trouve que le processeur est mono-coeur et mono-fil, alors la machine ne fait *rien d'autre* qu'attendre l'input de l'utilisateur.

En revanche, si on met la boucle dans le code utilisateur, le processus va faire plein d'appels système, mais il va régulièrement en sortir. Il peut donc recevoir des signaux, se faire tuer, se faire commuter si il prend trop de temps, etc... Autrement dit, le comportement qu'on attend d'un processus dans un noyau en multi-processus en temps partagé. Et surtout, les interruptions matérielles sont traitées par le système.

** Question E8

D'après le fichier app.bin.txt, le segment seg_code occupe les adresses [0x400000 ; 0x40134f] comprises, soient :

4944 octets

** Question E9

Makefile joint.

** Question F1

La première transaction sur le bus est une transaction rafale entre le maître, soit notre MIPS32 et la ROM, soit la target 0. C'est une requête en lecture des adresses 0xbfc00000, 0xbfc00004, 0xbfc00008, 0xbfc0000c qui correspondent bien aux adresses des quatre premières instructions de la fonction reset. La réponse à la première requête de la rafale est 0x27bd4000, soit l'instruction assembleur :

#+BEGIN_SRC mips
	  lui	    sp,0x200
#+END_SRC

D'après ce qu'on comprend de la trace, la première instruction du code du boot est exécuté au cycle 10 (pour une numérotation commençant à 0, soit le 11ème cycle, et pour une latence de la RAM de 0) :

#+BEGIN_QUOTE
,*******  cycle = 10 **************
bcu : fsm = IDLE
proc : <InsReq    valid mode MODE_KERNEL @ 0xbfc00000>
proc : <InsRsp    valid no error ins 0x3c1d0200>
proc : <DataReq invalid mode MODE_HYPER type DATA_READ @ 0 wdata 0 be 0>
proc : <DataRsp invalid no error rdata 0>
proc : ICACHE_IDLE  DCACHE_IDLE  PIBUS_IDLE
rom : IDLE
ram : IDLE
tty : IDLE   keyboard status[0] = 0   display status[0] = 0
  -- pibus signals -- 
req     = 0
gnt     = 0
sel_rom = 0
sel_ram = 0
sel_tty = 0
avalid  = 0
read    = 0x1
lock    = 0
address = 0xbfc0000c
ack     = 0x2
data    = 0x409a6000
#+END_QUOTE

C'est le premier cycle où InsRsp est valide, ce qui signifie qu'on a un cache hit sur l'adresse 0xbfc00000, et que donc le cache fournit la donnée 0x3c1d0200 au processeurs, qui la fait rentrer dans son pipeline.

La deuxième transaction sur le bus arrive au deuxième cache miss, soit au cycle 14 dans nos paramètres, parce qu'on a eu un cache miss sur l'adresse 0xbfc00010 :

#+BEGIN_QUOTE
,*******  cycle = 14 **************
bcu : fsm = IDLE
proc : <InsReq    valid mode MODE_KERNEL @ 0xbfc00010>
proc : <InsRsp  invalid no error ins 0x409a6000>
#+END_QUOTE

Cette deuxième transaction est donc une requête rafale en lecture à destination de la ROM, pour les adresses 0xbfc00010, 0xbfc00014, 0xbfc00018, 0xbfc0001c. La réponse à la première requête de la rafale est 0x3c1a0100, ce qui correspond à l'instruction assembleur :

#+BEGIN_SRC mips
	  lui	    k0,0x100
#+END_SRC

** Question F2

La première instruction à exécuter en mode utilisateur est demandée au cycle 50. C'est l'instruction située à l'adresse 0x004012dc, ce qui est bien la première instruction de main d'après app.bin.txt.

On a un cache miss, ce qui fait qu'on a une requête rafale en lecture, vers la ram, sur les adresses 0x004012d0, 0x004012d4, 0x004012d8, 0x004012dc (on demande trois adresses qui ne nous intéressent en fait pas, on ramène toute une ligne de cache).

L'instruction est effectivement exécutée au *cycle 60* : 

#+BEGIN_QUOTE
,*******  cycle = 60 **************
bcu : fsm = IDLE
proc : <InsReq    valid mode MODE_USER @ 0x4012dc>
proc : <InsRsp    valid no error ins 0x27bdffd0>
#+END_QUOTE

** Question F3

L'instruction de lecture du début de la chaîne de caractères "\n Hello World! \n" est l'instruction d'adresse 0x004012f0, celle-ci rentre dans le pipeline au cycle 91, le cache miss est détecté un cycle plus tard, au cycle 92, le bus est alloué au maître au cycle 93, et la demande rafale en lecture des adresses 0x01000070, 0x01000074, 0x01000078 (qui contient les 4 caractères '\n', ' ', 'H' et 'e' qui nous intéressent) et 0x0100007c (qui contient les 4 caractères 'l', 'l', 'o', ' ') est faite au cycle *94*, on peut donc dater la première transaction à ce cycle-là.

** Question F4

On recherche le cycle auquel on a la première écriture d'un caractère vers le tty.

La question est ambigüe. Il peut s'agir soit du moment où l'instruction d'écriture du caractère entre dans le pipeline, soit du moment où elle est effectivement exécutée, soit du moment où la transaction d'écriture est lancée sur le bus.

La première instruction processeur d'écriture vers l'adresse 0x90000000 intervient au cycle 1160 (elle est rentrée dans le pipeline au cycle 1159) :

#+BEGIN_QUOTE
,*******  cycle = 1160 **************
bcu : fsm = IDLE
proc : <InsReq    valid mode MODE_KERNEL @ 0x800007f4>
proc : <InsRsp    valid no error ins 0x8fc20014>
proc : <DataReq   valid mode MODE_KERNEL type DATA_WRITE @ 0x90000000 wdata 0xa be 0xf>
proc : <DataRsp   valid no error rdata 0>
proc : ICACHE_IDLE  DCACHE_WRITE_REQ  PIBUS_IDLE
rom : IDLE
ram : IDLE
tty : IDLE   keyboard status[0] = 0   display status[0] = 0
  -- pibus signals -- 
req     = 0
gnt     = 0
sel_rom = 0
sel_ram = 0
sel_tty = 0
avalid  = 0
read    = 0x1
lock    = 0
address = 0x800007fc
ack     = 0x2
data    = 0xafc20014
#+END_QUOTE

La première transaction d'écriture sur le bus vers l'adresse 0x90000000 (soit la partie display du TTY) intervient au cycle 1163 :

#+BEGIN_QUOTE
,*******  cycle = 1163 **************
bcu : fsm = AD | selected target = 2
proc : <InsReq    valid mode MODE_KERNEL @ 0x800007fc>
proc : <InsRsp    valid no error ins 0xafc20014>
proc : <DataReq invalid mode MODE_KERNEL type DATA_READ @ 0x2003f6c wdata 0 be 0xf>
proc : <DataRsp invalid no error rdata 0>
proc : ICACHE_IDLE  DCACHE_IDLE  PIBUS_WRITE_AD
rom : IDLE
ram : IDLE
tty : IDLE   keyboard status[0] = 0   display status[0] = 0
  -- pibus signals -- 
req     = 0
gnt     = 0
sel_rom = 0
sel_ram = 0
sel_tty = 0x1
avalid  = 0x1
read    = 0
lock    = 0
address = 0x90000000
ack     = 0x2
data    = 0xafc20014
#+END_QUOTE



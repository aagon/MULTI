#+TITLE : Prise de notes TP 4I106 MULTI
#+PROPERTY: header-args :mkdirp yes
#+STARTUP: inlineimages

Alain Greiner (alain.greiner@lip6.fr)

* TP 1 : 30/01/2020

Pour ce premier TP, on va d'intéresser au bus, qui est un bon exemple d'automate, et en particulier au Pi-bus, qui suit les règles suivantes :

Le pi-bus est un bus multimaître synchrone.

Deux types de composants matériels qui doivent communiquer entre eux :
- les maîtres sont par exemple les coeurs (et leurs caches privés)
- les cibles, comme la ram, la rom, le tty

La fonction du bus, c'est l'aiguillage et le routage.

On a avant toutes choses un bus de commandes, qui se décline en trois nappes de fils, ADDR (30 bits, puisqu'on ne ramène que des mots), OPC (4 bits), READ (1 bit).

Les seuls qui écrivent sur ce bus de commandes, ce sont les maîtres (et on peut d'ailleurs les définir comme ça).

On a un deuxième bus, le bus de réponses. Ce bus est unique, il s'appelle ACK (2 bits, car on a 3 réponses possibles READY, WAIT, ERROR) et seules les cibles peuvent écrire sur ce bus (on peut d'ailleurs les définir comme ça).

On a un bus de données qui est utilisé par les maîtres et les cibles (en effet, un maître veut pouvoir lire comme écrire).





On a un fil req et un fil gnt par maître qui arrive au BCU, bus control unit. (un des rarissimes automates non-Moore, donc Mealy général).

#+NAME: pibus
#+BEGIN_SRC dot

#+END_SRC


[dessin du pibus]


On peut spécifier un protocole du bus par son chronogramme :

Phase d'allocation : la demande du bus et la réponse doivent avoir lieu dans le même cycle d'horloge.

Phase d'adresse : les signaux Addr, lock, etc...

Phase de donnée : D et ACK 


L'allocation d'un nouveau maître peut se faire pendant le dernier (LOCK est à 0) cycle de la transaction n à condition que la valeur envoyée soit RDY ou ERROR.




** Question C1

*** Noeud IDLE

F : C(SEL)
A : C(READ).DELAY.SEL.ADR_OK
B : C(READ).C(DELAY).SEL.ADR_OK
C : READ.C(DELAY).SEL.ADR_OK
D : READ.DELAY.SEL.ADR_OK
E : C(ADR_OK).SEL

On a l'orthogonalité sur ce noeud :

F d'intersection nulle avec tous les autres (car SEL.C(SEL) = 0).
On se permet donc de l'éliminer.

E est d'intersection nulle avec tous les autres (car ADR_OK.C(ADR_OK) = 0)
On se permet donc de l'éliminer.

A est d'intersection nulle avec C et D (car READ.C(READ) = 0)
B est d'intersection nulle avec C et D (car READ.C(READ) = 0)

A est d'intersection nulle avec B (car DELAY.C(DELAY) = 0)

C est d'intersection nulle avec A et B (car READ.C(READ) = 0)
D est d'intersection nulle avec A et B (car READ.C(READ) = 0)
On a montré que A et B étaient d'intersection nulle avec tous les autres, et entre eux.
On peut donc éliminer A et B.

C est d'intersection nulle avec D (car DELAY.C(DELAY)).
On a montré que C et D étaient d'intersection nulle avec tous les autres, et entre eux.
On peut donc éliminer C et D.

On a bien l'orthogonalité pour IDLE.

La complétude :

A + B = C(READ).DELAY.SEL.ADR_OK + C(READ).C(DELAY).SEL.ADR_OK
A + B = C(READ).SEL.ADR_OK

C + D = READ.C(DELAY).SEL.ADR_OK + READ.DELAY.SEL.ADR_OK
C + D = READ.SEL.ADR_OK

Donc :

A + B + C + D = C(READ).SEL.ADR_OK + READ.SEL.ADR_OK
A + B + C + D = SEL.ADR_OK

Donc :

A + B + C + D + E = SEL.ADR_OK + SEL.C(ADR_OK)
A + B + C + D + E = SEL

Donc :

A + B + C + D + E + F = SEL + C(SEL) = 1

On a bien la somme de toutes les conditions de transition égale à 1.

*** Noeud R_WAIT

V : GO
V' : C(GO)

L'orthogonalité et la complétude sont triviale.

*** Noeud W_WAIT

U : GO
U' : C(GO)

L'orthogonalité et la complétude sont triviale.

*** Noeud R_OK

R : C(ADR_OK).SEL
S : ADR_OK.SEL
T : C(SEL)

L'orthogonalité est évidente :

T.R = 0
T.S = 0
R.S = 0

La complétude :

R + S = C(ADR_OK).SEL + ADR_OK.SEL
R + S = SEL

R + S + T = SEL + C(SEL) = 1

On a bien la complétude.

*** Noeud W_OK

X : ADR_OK.SEL
Y : C(ADR_OK).SEL
Z : C(SEL)

La démonstration de l'orthogonalité et de la complétude est symétrique à celle du noeud R_OK.

*** Noeud ERROR

On n'a pas de transition qui nous fait rester dans l'état ERROR.

On admet donc qu'on va dans l'état IDLE de manière inconditionnée.

G : 1

** Question C2

*** Noeud IDLE

Dans ces état, le matériel n'écrit pas sur le bus :

On a donc ACK_EN = 0
La valeur de ACK_VALUE n'a pas d'importance, on lui met NULL
On a DT_EN = 0 puisqu'on écrit pas sur le bus de données.
On n'écrit ni ne lit dans la mémoire, donc MEM_CMD est à NOP.

*** Noeud R_WAIT

Dans cet état, on écrit sur le bus ACK la valeur WAIT. On a donc besoin de mettre le signal ACK_VALUE à WAIT, et ACK_EN à 1.

On n'écrit pas sur le bus de données, puisque celles-ci ne sont pas encore prêtes (on envoie WAIT pour une raison). Donc DT_EN est à 0.

Le maître a demandé d'accéder à une zone de la mémoire en lecture, c'est donc la commande READ qu'on envoie vers la mémoire.

*** Noeud R_OK

Dans cet état, on écrit sur le bus ACK la valeur READY. On a donc besoin de mettre de signal ACK_VALUE à READY, et ACK_EN à 1.

On écrit sur le bus de données, puisque les données sont prêtes.

La commande à mettre dans MEM_CMD est ambigüe :
- Si on admet que la mémoire n'est pas capable d'obtenir une donnée dans le même cycle pendant lequel on lui a demandé, on n'aura jamais READ en sortie sur MEM_CMD pendant qu'on envoie la donnée sur le bus.
- Par contre, si on admet qu'elle en est capable, on a dans le même cycle READ sur MEM_CMD, puis dès la réception de la donnée (dans le même cycle donc) READY sur ACK_VALUE.

La valeur de ce fil en sortie dépend du paramètre L (NOP s'il est non nul, READ s'il est nul). (attention, on ne vient pas de transformer cette machine en machine de Mealy : L est un paramètre, choisi au démarrage de la machine, qui ne change plus ensuite.)

*** Noeud W_WAIT

Dans cet état, on écrit sur le bus ACK la valeur WAIT. On a donc besoin de mettre le signal ACK_VALUE à READY, et ACK_EN à 1.

On n'écrit pas sur le bus de données, on a reçu une instruction d'écriture, donc DT_EN est à 0.

Le maître a demandé d'accéder à une zone de la mémoire en écriture, c'est donc la commande WRITE qu'on envoie vers la mémoire.

*** Noeud W_OK

Dans cet état, on écrit sur le bus ACK la valeur READY. On a donc besoin de mettre de signal ACK_VALUE à READY, et ACK_EN à 1.

On n'écrit pas sur le bus de données, on a reçu une instruction d'écriture, donc DT_EN est à 0.

Pour la même raison que pour R_OK, la valeur de MEM_CMD dépendraa du paramètre L

*** Noeud ERROR

Dans cet état, on écrit sur le bus ACK pour signaler l'erreur.

On n'écrit pas sur le bus de données, on n'a rien à y écrire, ni aucune commande non plus à envoyer à la mémoire.

*** Résumé

|        | ACK_EN | ACK_VALUE | DT_EN | MEM_CMD                   |
|--------+--------+-----------+-------+---------------------------|
| IDLE   |      0 | NULL      |     0 | NOP                       |
| R_WAIT |      1 | WAIT      |     0 | READ                      |
| R_OK   |      1 | READY     |     1 | NOP (si !L), READ (si L)  |
| W_WAIT |      1 | WAIT      |     0 | WRITE                     |
| W_OK   |      1 | READY     |     0 | NOP (si !L), WRITE (si L) |
| ERROR  |      1 | ERROR     |     0 | NOP                       |


A priori, on n'a écrit sur les bus ACK comme DT qu'au moment où on avait le droit de le faire. En effet, si on se rappelle le chronogramme du PIBUS, les différents états : R_WAIT R_OK W_WAIT W_OK ERROR n'arrivent qu'après une demande du maître. On a donc le bus réservé pour la réponse (donc aucun problème pour le bus ACK), et éventuellement le bus DT réservé si on a une donnée à transmettre.

Donc notre fonction de génération ne créé pas de court-circuits.

** Question D1

*** Noeud INIT

On passe de INIT à RAM_REQ de manière inconditionnée.

Donc A = 1

*** Noeud RAM_REQ

* TP 2 : 07/02/2020

*** Question C1

On a direct mapping, soit icache_ways = 1

On a 16 octets par ligne de cache, soit 4 mots, donc icache_words = 4

1024 / 16, soient 64 lignes, donc icache_sets = 64

*** Question C2

Il faut pouvoir garantir que la machine rebootera après un arrêt intempestif.

Pour que notre automate soit déterministe, il faut qu'il ait un unique état initial connu et constant.

Cet état initial est donné par le contenu du segment seg_reset.

Il faut absolument que ce segment mappe vers une zone de la mémoire en lecture seule.

*** Question C3

Le segment seg_tty doit être non cachable, parce que les caractères affichés dans le terminal doivent toujours correspondre effectivement à ce que le processeur connaît.

Le cache permet que ces deux valeurs soient différentes, même transitoirement, et c'est inacceptable.

*** Question C4

Les segments protégés sont :
- seg_reset
- seg_kcode
- seg_kdata
- seg_kdata
- seg_tty

On le repère à ce que ils font partie des adresses hautes (bit de poids fort à 1).

*** Question D1

Le programme utilisateur doit donner au noyau :
- la référence de l'appel système qu'il appelle
- les paramètres

La première information est facile à transmettre :
Les noms et les comportements des appels systèmes sont réputés connus de l'utilisateur : il suffit de passer un nom, et le noyau a une liste statique des appels systèmes. Il cherche dans sa liste et trouve (ou non, auquel cas il rend une erreur)

La deuxième information est un peu plus délicate à transmettre : le noyau et le userspace n'ont pas la même pile : le noyau, qui a tous les droits, peut aller chercher les arguments directement dans la pile utilisateur du processus qui a fait l'appel système (c'est ce que faisait unix v5).

Sinon, comme c'est le cas ici, on peut stocker les arguments dans des registres visibles du processeur. Cette technique suppose une quantité limitée d'arguments.

*** Question D2

Le tableau _cause_vector contient les raisons d'entrée en mode noyau. Il est initialisé dans le fichier exc_handler.c.

Le tableau _syscall_vector contient les adresses des handlers des appels systèmes. Il est initialisé dans le fichier sys_handler.c.

D'après le code assembleur de la fonction _sys_handler, les handlers des appels systèmes sont indexés par leurs 5 bits de poids faible (donc 32 handlers) :

#+BEGIN_SRC mips
	  andi        $26,$2,0x1F
#+END_SRC

*** Question D3

Dans l'ordre :

L'utilisateur appelle la fonction utilisateur proctime().

La fonction proctime() appelle la fonction inlinée sys_call(), avec comme premier argument 0x01, soit l'index de la fonction *noyau* _proctime() dans le tableau _syscall_vector.

La fonction syscall() enregistre dans des registres du processeur les arguments de la fonction, et il appelle l'instruction MIPS "syscall".

On imagine seulement que cette instruction permet de passer en mode noyau (donc de rendre accessible des instructions processeur et des adresses), et de jump à une adresse bien précise. Ce passage en mode noyau se fait au moyen d'une trappe, soit d'une interruption matérielle.

On fait l'hypothèse, appuyée sur le code, qu'on saute à l'adresse 0x80000000, soit l'adresse de la fonction assembleur _giet. Cette fonction assembleur du noyau a pour but de regarder quelle est la cause de l'interruption matérielle. Il se trouve que la cause de l'interruption matérielle courante suppose l'appel à la fonction assembleur _sys_handler.

_sys_handler saute vers la fonction _proctime :

#+BEGIN_SRC mips
	  jalr        $3
	  mtc0        $0,$12                 
#+END_SRC

(on est en MIPS 32 bits, avec 5 étages de pipeline et un delayed slot : la désactivation des interruptions est lancée avant le passage à la fonction)

La fonction _proctime consiste en une ligne d'assembleur, qui va lire le contenu du registre $9 du coprocesseur 0, censé apparemment contenir le nombre de cycles de processeurs écoulés depuis le démarrage de la machine (on ne sait pas trop comment, le code ne permet pas de le dire).

Cette valeur est copiée dans une variable de la pile, appelée ret. Cette variable est retournée par la fonction.

On se retrouve à la ligne suivante :

#+BEGIN_SRC mips
	  lw          $26,16($29)
	  mtc0        $26,$12
#+END_SRC

La fin de la fonction restaure les pointeurs de pile et d'instructions.

On se retrouve en mode utilisateur, à la fin de la fonction sys_call().

Qui retourne la valeur qui a été opportunément placée dans la pile au bon endroit (dans la variable reg_no_and_output).

On se trouve à la fin de la fonction proctime().

*** Question D4

Cet appel système dont on vient de détailler le déroulement a le coût en *instructions* suivant :

Le branchement est fait dans proctime().

On charge dans les registres les 5 paramètres (5 LW)
On exécute l'instruction assembleur syscall (1 instruction)
On exécute les 6 instructions assembleur de _giet (6 instructions)
On exécute les 17 instructions assembleur de _sys_handler jusqu'au jalr (17 instructions)
On exécute l'unique instruction assembleur de la fonction _proctime (1 instruction)

(dans les faits, on va devoir compiler, puis regarder l'assembleur produit par le compilateur)

*** Question E1

Le code de boot doit être exécuté en mode superviseur parce que le boot consiste entre autres à charger le code du noyau en mémoire centrale, et en zone noyau de la mémoire centrale. Pour accéder en écriture à cette zone, on doit être en mode noyau.

Dans notre cas, quand bien même on suppose le code du noyau déjà chargé en mémoire au démarrage de la machine, on est quand même censé manipuler des registres, comme le registre SR, qui n'est accessible qu'en mode noyau.

*** Question E2

Le point d'entrée du code applicatif doit se trouver au début du segment seg_data_base (soit)


*** Question E3

Si les adresses définies dans ces deux fichiers ne sont pas égales entre elles, le logiciel essaiera d'accéder à des adresses erronnées, puisque la base des segments pour le logiciel ne sera pas la même que la base des segments pour le matériel.

*** Question E4

Le segment seg_reset contient le code de la fonction assembleur reset.
Le segment seg_kcode contient le code de la fonction assembleur giet (le point d'entrée du noyau) et le code des sections .text (qui est en fait ) de tous les codes objets produits à partir des sources compilées.

*** Question E5

D'après le fichier sys.bin.txt, le segment seg_reset va des adresses [0xbfc00000 ; 0xbfc00023], soit 36 octets.

D'après le fichier sys.bin.txt, le segment seg_kcode effectivement occupé va des adresses [0x80000180 ; 0x8000227c] compris, soit :

8448 octets

*** Question E6

#+BEGIN_SRC c
  #include "stdio.h"

  __attribute__((constructor)) void main()
  {
	  char c;
	  char s[] = "\n Hello World! \n";

	  while (1) {
		  tty_puts(s);
		  tty_getc(&c);
	  }
  }
#+END_SRC


*** Question E7







